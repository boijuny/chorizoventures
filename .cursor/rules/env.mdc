---
description: 
globs: 
alwaysApply: true
---
# Environment & Development Setup Rules

## 🐍 Conda Environment

- Always run commands in the `guezvc` conda environment
- Activate environment before any development work: `conda activate guezvc`
- Verify environment is active before installing packages or running scripts
- Use environment-specific Node.js and npm versions

## 📦 Package Management

- Use `npm` for package installation (not yarn or pnpm)
- Install packages with exact versions for production dependencies
- Update `package.json` and `package-lock.json` together
- Run `npm audit` regularly to check for security vulnerabilities

## 🔧 Development Tools

- Use TypeScript strict mode for all code
- Run ESLint and Prettier before commits
- Use Next.js 14 App Router conventions
- Leverage Tailwind CSS for all styling
- Use Framer Motion for animations

## 🌍 Environment Variables

- Store sensitive data in environment variables
- Use `.env.local` for local development
- Never commit API keys or secrets to version control
- Reference environment variables through `process.env`
- Document required environment variables in technical specs

## 🏗 Build & Development

- Use `npm run dev` for local development server
- Run `npm run build` to verify production builds
- Use `npm run lint` to check code quality
- Run `npm run test` for testing (when implemented)
- Check bundle size with `npm run analyze` (if available)

## 📁 File Organization

- Follow Next.js App Router file structure
- Place components in appropriate subdirectories
- Use TypeScript for all `.ts` and `.tsx` files
- Organize utilities in `lib/` directory
- Keep types in `types/` directory

## 🔄 Git Workflow

- Work on feature branches, not main
- Commit frequently with descriptive messages
- Use conventional commit format when possible
- Test locally before pushing to remote
- Keep commits focused on single features or fixes

## 🚀 Deployment Considerations

- Verify builds work locally before deployment
- Check environment variables are set correctly
- Test in production-like environment when possible
- Monitor performance after deployments
- Roll back if critical issues are detected 